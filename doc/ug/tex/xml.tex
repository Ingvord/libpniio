%%%documentation concerning the XML functions

In many cases (see Section~\ref{sec:xml::usecases}) an ASCII representation of a
\nexus-file is required. 

As \nexus\ organizes data objects in a tree like manner, XML is the obvious ASCII
representation for a \nexus\ file.
\libpniio\ thus provides a small but powerful set of functions to read and write 
\nexus\ data objects from and to XML files. The framework is based on the 
\cpp{boost::property\_tree} library. Clearly, the XML functionality provided 
by \libpniio\ does in no case replace a full XML parser. For instance, there are
no functions provided to manipulate the the XML content returned from 
any of the functions. However, as the \cpp{node} type used to represent 
XML data is an alias for the \cpp{boost::property\_tree} node type, one can use
functions from \cpp{boost::property\_tree} to do some additional work with the
XML results.
\libpniio\ provides two interfaces\
\begin{itemize}
\item a high level interface which consists of basically two functions. The high
level interface is described in section~\ref{sec:xml:highlevel}
\item And a low level interface -- these are the classes and functions used to
build the high level interface (described in section~\ref{sec:xml:lowlevel}).
\end{itemize}
Aside from this there are some simple functions which are common to both
interfaces and described in section~\ref{sec:xml:basic}.

%%%---------------------------------------------------------------------------
\section{Use cases}\label{sec:xml:usecases}

\subsection{Generating \nexus\ structures from XML}

\nexus-files, when properly used, can store much more information than a typical
ASCII data file.
The structure of a \nexus\ file can become rather complex. In a rather complex 
environment like at a synchrotron beamline it would be naive to use static 
code to create the file. A more feasible approach would be to implement 
generic code which generates the structure of a file from an XML template. 
The template could be generated either manually by the user or by means 
of another program written in whatever language is reasonable for this purpose. 

\subsection{Metadata ingestion of a file}

In some situations a $3$rd party may needs to process some of the metadata 
stored in the file while not having access to the file. One possible application
would be a data catalogue. Instead of making the file available the XML dump 
of the \nexus\ file could be sent to the system while moving the \nexus\ file 
to its final location on the storage system.

%%%---------------------------------------------------------------------------
\section{Basic XML handling}{\label{sec:xml:basic}

All XML related functions and classes resided within a separate namespace 
\cpp{pni::io::nx::xml}. An XML document is represented by an instance of 
type \cpp{node}. \cpp{node} is an alias for \cpp{boost::property\_tree::ptree}. 
Thus it can be used along with all functions an methods provided by the 
\cpp{ptree} type provided by \cpp{boost::property\_tree}. Aside from the 
functionality from \cpp{boost::property\_tree} \libpniio\ provides some 
\nexus\ related convenience functions. 

An instance of \cpp{node} can be created either from a string
\begin{cppcode}
    xml::node n = xml::create_from_string(xmldata);
\end{cppcode}
where \cpp{xmldata} is a string with the XML content, 
or from a file
\begin{cppcode}
    xml::node n = xml::create_from_file(fname);
\end{cppcode}
where \cpp{fname} is a string with the name of the file. Both functions 
return the root node of the XML document. See the \cpp{property\_tree}
documentation in the \cpp{BOOST} distribution for more information what one can
do with such an object. For the rest of this chapter no additional knowledge
about \cpp{BOOST}s \cpp{property\_tree} library is required.
To write the content of a node to a stream one can use the default 
output stream operator
\begin{cppcode}
    xml::node n = ....;
    std::cout<<n<<std::endl;
\end{cppcode}


%%%===========================================================================
\section{High level XML interface}\label{sec:xml:highlevel}

The high-level XML interface basically consists of two function templates 
\begin{description}
\item[xml\_to\_nexus] which creates \nexus\ objects from XML templates
\item[nexus\_to\_xml] which generates XML from \nexus\ objects.
\end{description}
Additionally there are some convenience functions available. All of this will be
described in more detail in this section.

%%%---------------------------------------------------------------------------
\section{\nexus\ objects from XML}\label{sec:xml::nxtoxml}

Creating \nexus\ objects from XML might be the most common operation performed 
by this part of the library. The next example illustrates the most common 
use case 
\begin{cppcode}
#include <pni/io/nx/nx.hpp>
#include <pni/io/nx/xml.hpp>

using namespace pni::io::nx;

int main(int argc,char **argv)
{
    xml::node n = ....;
    h5::nxfile f = ....;
    h5::nxgroup root = f.root();
    
    xml::xml_to_nexus(n,root);

    return 0;
}
\end{cppcode}
Here, the structure of a \nexus\ tree is described by XML and then converted 
to \nexus\ by means of the \cpp{xml\_to\_nexus} function. The first argument 
of this function is the XML node while the second is the parent object 
below which the new structure should be created. All data already available 
in the XML file will be stored in the fields and attributes of the created
\nexus\-tree. 


%%%---------------------------------------------------------------------------
\subsection{XML from \nexus\ objects}\label{sec:xml:xmltonx}

The work horse for \nexus\ to XML conversion is the \cpp{nexus\_to\_xml} function
template. The most probably simplest use case is demonstrated in the next
example 
\begin{cppcode}
#include <pni/io/nx/nx.hpp>
#include <pni/io/nx/xml.hpp>

using namespace pni::io::nx;

int main(int argc,char **argv)
{
    h5::nxfile f = ....;
    h5::nxgroup root = f.root();

    xml::node root_node;
    xml::nexus_to_xml(root,root_node);
    std::cout<<root_node<<std::endl;

    return 0;
}
\end{cppcode}
Here, the entire structure of the \nexus\ file is stored below the XML root node 
which is at the end dumped to standard output.
This simple example already raises an important question: how to deal with the
data stored in the \nexus\ file. As \nexus\ files can be used to store large amounts
of data it would not be wise to convert all this data to ASCII (think about a 3D
image stack stored in the file). However, some data might be required. 
The \cpp{nexus\_to\_xml} template thus provides a third optional argument which 
is a predicate function which decides for which field or attribute data will be
written to the file. 
The signature of the predicate is 
\begin{minted}[fontsize=\small]{cpp}
template<
         typename GTYPE,
         typename FTYPE,
         typename ATYPE
        >
bool predicate(const nxobject<GTYPE,FTYPE,ATYPE> &o);
\end{minted}
The function returns \cpp{true} if the data of a particular object should be 
included in the XML output. 
It is wise to not make this function to specific. Thus, the name of a field 
is not a good criterion for deciding whether or not to write data. 
A much better approach is to check for certain properties of an object. 
For the previous example a possible predicate could look like this
\begin{cppcode}
//code omitted 
bool write_scalars(const h5::nxobject &o)
{
    if(is_field(o) || is_attribute(o))
    {
       return size(o)==1;
    }
    else 
        return false;
}

int main(int argc,char **argv)
{
    //code omitted 
    xml::nexus_to_xml(root,root_node,write_scalars);

    //code omitted
    return 0;
}
\end{cppcode}
This predicate determines that only the data from fields and attributes 
is written to the XML tree if their size is equal to $1$ (in other words -- only
scalars are written to the file). 
Such an approach keeps the resulting XML document small while using a rather 
general predicate which would match quite a lot of use cases. The default 
policy is to write no data.


%%%===========================================================================
\section{The XML low level interface}\label{sec:xml:lowlevel}

The entire XML stack in \libpniio\ is based upon the \cpp{boost::property\_tree} 
library. The \cpp{pni::io::nx::xml::ptree} type is nothing else than an alias to
the \cpp{node} type provided by the \cpp{property\_tree} library.

%%%----------------------------------------------------------------------------
\subsection{Basic \cpp{node}-operations}

In order to simplify the work with \cpp{boost::property\_tree} \libpniio\ has
introduced some convenience functions. 
To create a new XML node one could use either 
\begin{cppcode}
xml::node = xml::create_from_string("....");
\end{cppcode}
or
\begin{cppcode}
xml::node = xml::create_from_file("filename.xml");
\end{cppcode}
The former function returns a node which refers to the root element of the 
XML structure provided by a string passed to the function as its only argument. 
The latter one reads the XML data from a file and returns a handle to its 
root element too.

\cpp{boost::property\_tree} uses nodes to store attributes of a tag which are 
accessible under a special name. To make accessing the attributes simpler 
there two functions.  
\begin{cppcode}
if(xml::has_attribute(field_node,"units"))
{
    xml::units_node = get_attribute(field_node,"units");

    // do something with the attribute
}
\end{cppcode}
\cpp{has\_attribute} returns true of a node possesses a particular attribute of
given name and \cpp{get\_attribute} returns a node instance referring to this 
attribute. 
The \cpp{xml::node} type and its related functions are provided by the
\cpp{xml/node.hpp} header file.

%%%---------------------------------------------------------------------------
\subsection{Handling tags}

Each tag in \libpniio's XML protocol is handled by an individual class and its
static methods. Each of these \emph{tag}-classes provides two major methods 
\cpp{object\_from\_xml} and \cpp{object\_to\_xml}. The former one creates a new
object of the tags type in memory while the latter one creates an XML
representation from a particular type.

\subsubsection{The \cpp{dimensions} tag}

The \cpp{dimensions} tag provides information about the number of elements 
along each dimension of a multi-dimensional field or attribute. This tag is
handled by the \cpp{dimensions} class provided by \cpp{xml/dimensions.hpp}
header file. 
The \cpp{dimensions} class allows for inquiry of the \cpp{dimensions} tag within
the XML structure. 
\begin{cppcode}
xml::node dims = .....;

std::cout<<"rank: "<<dimensions::rank(dims)<<std::endl;
std::cout<<"size: "<<dimensions::size(dims)<<std::endl;
\end{cppcode}
The \cpp{rank} member function returns the number of dimensions of the 
dimensions tag and the \cpp{size} method the total number of elements 
described by the \cpp{dimensions}-tag.

The memory representation of the \cpp{dimensions}-tag is a container 
whose elements are of type \cpp{size\_t} or any other compatible integer type. 
The default container is the \cpp{shape\_t} type provided by \libpnicore. 
To create an instance of \cpp{shape\_t} use
\begin{cppcode}
shape_t shape = dimensions::object_from_xml(dims);
\end{cppcode}
However, there is also a template version of \cpp{object\_from\_xml} 
\begin{cppcode}
typedef std::list<uint128> dim_type;
auto shape = dimensions::object_from_xml<dim_type>(dims);
\end{cppcode}
which can be used to store the number of elements in an arbitrary container.

The inverse operation, building a \cpp{dimensions}-tag from a container is 
implemented by the \cpp{object\_to\_xml} member function. 
\begin{cppcode}
shape_t shape{...};
xml::node dim_node = dimensions::object_to_xml(shape);
\end{cppcode}
This template member function accepts an arbitrary container with integer 
elements as its only argument and return a \cpp{xml::node} instance 
with the shape data.


\subsubsection{The \cpp{attribute} tag}
\todo[inline]{Describe attribute tag handling}

\subsubsection{The \cpp{group} tag}
\todo[inline]{Describe group tag handling}

\subsubsection{The \cpp{field} tag}
\todo[inline]{Describe field tag handling}

\subsubsection{The \cpp{link} tag}
\todo[inline]{Describe link tag handling}





