%%%documentation concerning the XML functions

As Nexus organizes data objects in a tree like manner, XML is the obvious ASCII
representation for a Nexus file.
\libpniio\ thus provides a small but powerful set of functions to read and write 
Nexus data objects from and to XML files. The framework is based on the 
\cpp{boost::property\_tree} library. 
There are several use cases which should be discussed briefly in 

%%%---------------------------------------------------------------------------
\section{Use cases}\label{sec:xml:usecases}

XML is a powerful and mature technology for representing structured data in 
ASCII. Though it has received some competitors like JSON, when it comes to 
complex structures XML is still the tool of choice\footnote{In fact, JSON
becomes quickly virtually unreadable if the structure becomes too deeply
nested.}
In this section some use cases for Nexus and XML will be presented. 

\subsection{Standard compliance verification of a file}

An always recurring request is the possibility to check a Nexus file with
respect to its compliance to the current standard. As the Nexus standard 
itself is defined in XML it would be reasonable to create an XML representation
of the file to check and use one of the available XML validation tools to 
verify the compliance of the file towards a particular standard. 
Using the XML representation of the file instead of the file directly has 
several advantages 
\begin{itemize}
\item being rather small, the XML representation can also be transfered 
over the network using a remote service for validation
\item it is at least in principle human readable 
\item many of the required tools already exist. 
\end{itemize}
On step in this entire process is to convert a Nexus file to its ASCII XML 
representation.

\subsection{Generating Nexus structures from XML}

The structure of a Nexus file can become rather complex. In a rather complex 
environment like at a synchrotron beamline it would be naive to use static 
code to create the file. A more feasible approach would be to implement 
generic code which generates the structure of a file from an XML template. 
The template could be generated either manually by the user or by means 
of another program written in whatever language is reasonable for this purpose. 

\subsection{Metadata ingestion of a file}

In some situations a $3$rd party may needs to process some of the metadata 
stored in the file while not having access to the file. One possible application
would be a data catalogue. Instead of making the file available the XML dump 
of the Nexus file could be sent to the system while moving the Nexus file 
to its final location on the storage system.

%%%---------------------------------------------------------------------------
\section{Nexus objects from XML}\label{sec:xml::nxtoxml}

%%%---------------------------------------------------------------------------
\section{XML from Nexus objects}\label{sec:xml::xmltonx}

The work horse for Nexus to XML conversion is the \cpp{nexus\_to\_xml} function
template. The most probably simplest use case is demonstrated in the next
example 
\begin{cppcode}
#include <pni/io/nx/nx.hpp>
#include <pni/io/nx/xml.hpp>

using namespace pni::io::nx;

int main(int argc,char **argv)
{
    h5::nxfile f = ....;
    h5::nxgroup root = f.root();

    xml::node root_node;
    xml::nexus_to_xml(root,root_node);
    std::cout<<root_node<<std::endl;

    return 0;
}
\end{cppcode}
Here, the entire structure of the Nexus file is stored below the XML root node 
which is at the end dumped to standard output.
This simple example already raises an important question: how to deal with the
data stored in the Nexus file. As Nexus files can be used to store large amounts
of data it would not be wise to convert all this data to ASCII (think about a 3D
image stack stored in the file). However, some data might be required. 
The \cpp{nexus\_to\_xml} template thus provides a third optional argument which 
is a predicate function which decides for which field or attribute data will be
written to the file. 
The signature of the predicate is 
\begin{minted}[fontsize=\tiny]{cpp}
template<
         typename GTYPE,
         typename FTYPE,
         typename ATYPE
        >
bool predicate(const nxobject<GTYPE,FTYPE,ATYPE> &o);
\end{minted}
The function returns \cpp{true} if the data of a particular object should be 
included in the XML output. 
It is wise to not make this function to specific. Thus, the name of a field 
is not a good criterion for deciding whether or not to write data. 
A much better approach is to check for certain properties of an object. 
For the previous example a possible predicate could look like this
\begin{cppcode}
//code omitted 
bool write_predicate(const h5::nxobject &o)
{
    if(is_field(o) || is_attribute(o))
    {
       return size(o)==1;
    }
    else 
        return false;
}

int main(int argc,char **argv)
{
    //code omitted 
    xml::nexus_to_xml(root,root_node,write_predicate);

    //code omitted
    return 0;
}
\end{cppcode}
This predicate determines that only the data from fields and attributes 
is written to the XML tree if their size is equal to $1$ (in other words -- only
scalars are written to the file). 
Such an approach keeps the resulting XML document small while using a rather 
general predicate which would match quite a lot of use cases.

