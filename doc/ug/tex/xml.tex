%%%documentation concerning the XML functions

As \nexus\ organizes data objects in a tree like manner, XML is the obvious ASCII
representation for a \nexus\ file.
\libpniio\ thus provides a small but powerful set of functions to read and write 
\nexus\ data objects from and to XML files. The framework is based on the 
\cpp{boost::property\_tree} library. Clearly, the XML functionality provided 
by \libpniio\ does in no case replace a full XML parser. For instance, there are
no functions provided to manipulate the the XML content returned from 
any of the functions. However, as the \cpp{node} type used to represent 
XML data is an alias for the \cpp{boost::property\_tree} node type, one can use
functions from \cpp{boost::property\_tree} to do some additional work with the
XML results.
\libpniio\ provides two interfaces\
\begin{itemize}
\item a high level interface which consists of basically two functions. The high
level interface is described in section~\ref{sec:xml:highlevel}
\item And a low level interface -- these are the classes and functions used to
build the high level interface (described in section~\ref{sec:xml:lowlevel}).
\end{itemize}
Aside from this there are some simple functions which are common to both
interfaces and described in section~\ref{sec:xml:basic}.

%%%---------------------------------------------------------------------------
\subsection{Basic XML handling}{\label{sec:xml:basic}

All XML related functions and classes resided within a separate namespace 
\cpp{pni::io::nx::xml}. An XML document is represented by an instance of 
type \cpp{node}. \cpp{node} is an alias for \cpp{boost::property\_tree::ptree}. 
Thus it can be used along with all functions an methods provided by the 
\cpp{ptree} type provided by \cpp{boost::property\_tree}. Aside from the 
functionality from \cpp{boost::property\_tree} \libpniio\ provides some 
\nexus\ related convenience functions. 

An instance of \cpp{node} can be created either from a string
\begin{cppcode}
    xml::node n = xml::create_from_string(xmldata);
\end{cppcode}
where \cpp{xmldata} is a string with the XML content, 
or from a file
\begin{cppcode}
    xml::node n = xml::create_from_file(fname);
\end{cppcode}
where \cpp{fname} is a string with the name of the file. Both functions 
return the root node of the XML document. See the \cpp{property\_tree}
documentation in the \cpp{BOOST} distribution for more information what one can
do with such an object. For the rest of this chapter no additional knowledge
about \cpp{BOOST}s \cpp{property\_tree} library is required.
To write the content of a node to a stream one can use the default 
output stream operator
\begin{cppcode}
    xml::node n = ....;
    std::cout<<n<<std::endl;
\end{cppcode}


%%%===========================================================================
\subsection{High level XML interface}\label{sec:xml:highlevel}

The high-level XML interface basically consists of two function templates 
\begin{description}
\item[xml\_to\_nexus] which creates \nexus\ objects from XML templates
\item[nexus\_to\_xml] which generates XML from \nexus\ objects.
\end{description}
Additionally there are some convenience functions available. All of this will be
described in more detail in this section.

%%%---------------------------------------------------------------------------
\subsection{\nexus\ objects from XML}\label{sec:xml::nxtoxml}

Creating \nexus\ objects from XML might be the most common operation performed 
by this part of the library. The next example illustrates the most common 
use case 
\begin{cppcode}
#include <pni/io/nx/nx.hpp>
#include <pni/io/nx/xml.hpp>

using namespace pni::io::nx;

int main(int argc,char **argv)
{
    xml::node n = ....;
    h5::nxfile f = ....;
    h5::nxgroup root = f.root();
    
    xml::xml_to_nexus(n,root);

    return 0;
}
\end{cppcode}
Here, the structure of a \nexus\ tree is described by XML and then converted 
to \nexus\ by means of the \cpp{xml\_to\_nexus} function. The first argument 
of this function is the XML node while the second is the parent object 
below which the new structure should be created. All data already available 
in the XML file will be stored in the fields and attributes of the created
\nexus\-tree. 


%%%---------------------------------------------------------------------------
\subsubsection{XML from \nexus\ objects}\label{sec:xml:xmltonx}

The work horse for \nexus\ to XML conversion is the \cpp{nexus\_to\_xml} function
template. The most probably simplest use case is demonstrated in the next
example 
\begin{cppcode}
#include <pni/io/nx/nx.hpp>
#include <pni/io/nx/xml.hpp>

using namespace pni::io::nx;

int main(int argc,char **argv)
{
    h5::nxfile f = ....;
    h5::nxgroup root = f.root();

    xml::node root_node;
    xml::nexus_to_xml(root,root_node);
    std::cout<<root_node<<std::endl;

    return 0;
}
\end{cppcode}
Here, the entire structure of the \nexus\ file is stored below the XML root node 
which is at the end dumped to standard output.
This simple example already raises an important question: how to deal with the
data stored in the \nexus\ file. As \nexus\ files can be used to store large amounts
of data it would not be wise to convert all this data to ASCII (think about a 3D
image stack stored in the file). However, some data might be required. 
The \cpp{nexus\_to\_xml} template thus provides a third optional argument which 
is a predicate function which decides for which field or attribute data will be
written to the file. 
The signature of the predicate is 
\begin{minted}[fontsize=\small]{cpp}
template<
         typename GTYPE,
         typename FTYPE,
         typename ATYPE
        >
bool predicate(const nxobject<GTYPE,FTYPE,ATYPE> &o);
\end{minted}
The function returns \cpp{true} if the data of a particular object should be 
included in the XML output. 
It is wise to not make this function to specific. Thus, the name of a field 
is not a good criterion for deciding whether or not to write data. 
A much better approach is to check for certain properties of an object. 
For the previous example a possible predicate could look like this
\begin{cppcode}
//code omitted 
bool write_scalars(const h5::nxobject &o)
{
    if(is_field(o) || is_attribute(o))
    {
       return size(o)==1;
    }
    else 
        return false;
}

int main(int argc,char **argv)
{
    //code omitted 
    xml::nexus_to_xml(root,root_node,write_scalars);

    //code omitted
    return 0;
}
\end{cppcode}
This predicate determines that only the data from fields and attributes 
is written to the XML tree if their size is equal to $1$ (in other words -- only
scalars are written to the file). 
Such an approach keeps the resulting XML document small while using a rather 
general predicate which would match quite a lot of use cases. The default 
policy is to write no data.


%%%===========================================================================
\subsection{The XML low level interface}\label{sec:xml:lowlevel}


