
In times of binary data formats like Nexus it seems anachronistic to devote an
entire chapter of the appendix to the problem of ASCII parsing. However, 
ther are several good reasons why one should care about correctly reading 
ASCII data (in particular numbers)
\begin{enumerate}
\item for historical reasons there is a lot of legacy ASCII data out there which
may should be processed -- for this reason alone it is necessary to deal with
ASCII data in a reasonable way.
\item uses still provided input to programs via ASCII files (for instance using
XML) or via the command line -- in both cases the program has to process these
files correctly. 
\item even input fields in GUI toolkits typically return the data entered by 
the user as an characater string which must be parsed in order to obtain a 
numerical value.
\end{enumerate}

One crucial aspect when processing ASCII data is number parsing.
This chapter will describe in more detail the parser framework provided by 
\libpniio. 

All parsers basically utilize two exceptions to denote errors
\begin{description}
\item[\texttt{parser\_error}] which is thrown in situations where the ASCII 
representation is malformed, or
\item[\texttt{range\_error}] which is thrown when the ASCII string is well 
formatted but the numeric range represented by the number exceeds the 
target type {\bf not yet implemented}
\end{description}
This information should be sufficient to recognize the error in the input data. 
Before discussing the individual functions and types provided by \libpniio\ 
for parsing ASCII a thorough discussion of the ASCII representations of 
the primitive data types will be made.

%%----------------------------------------------------------------------------
\section{ASCII representations of primitive data types}

\subsection{Integers and floating point numbers}
The ASCII representations of integer and floating point numbers follow the 
C++ standard conventions and will not be discussed here in greater detail.

\subsection{Complex numbers}

Complex numbers can be represented in two forms: as real and imaginary part 
or as imaginary part only. A real-part only representation is not possible 
as such a number would be indistinguishable from a simple floating point type. 
The full representation (real and imaginary part) looks somehow like this
\begin{align}
A \pm K B
\end{align}
where $A$ and $B$ are denoting the real and imaginary part respectively. 
$K$ is the symbol which denotes the complex unit $\sqrt{-1}$. This can be either
$i$, $j$, or $I$. To given an example 
\begin{verbatim}
1.2+j3.4
\end{verbatim}
would be a valid complex number while
\begin{verbatim}
1.2+J2.4
\end{verbatim}
not. It is important to not that the sign between the real- and imaginary-part 
must not be surrounded by blanks. Furthermore, the imaginary part must not have
an extra leading sign as its sign is already determined by the sign between
real- and imaginary part. 
A imaginary-part only number would look like this
\begin{verbatim}
+i3
\end{verbatim}
where the sign in front of the complex unit is optional and could have been 
omitted in this particular case 
\begin{verbatim}
i3
\end{verbatim}

\subsection{Boolean values}

The two boolean values \cpp{true} and \cpp{false} are represented exactly in
this way as ASCII strings. Be aware that the syntax is case sensitive. Thus 
\cpp{True} or \cpp{False} would cause a \cpp{parser\_error}.

%%----------------------------------------------------------------------------
\section{Parser rules}



