%%%describing the basic usage

This chapter deals with the basic interface provided by the layer 1 types
implemented in \libpniio. All types concerning Nexus reside in one of the
namespaces embedded in {\tt pni::io::nx}. The namespaces below this one 
indicate either a particular storage backend (currently only HDF5 is
implemented).

To use the Nexus part of the library just add 
\begin{cppcode}
#include <pni/io/nx/nx.hpp>
\end{cppcode}
to your source file. 

%%%===========================================================================
\section{Working with files}
\input{tex/nexus_files.tex}


%%%===========================================================================
\section{Working with groups}

Nexus groups are instances of the {\tt nxgroup} template. They can be considered
as containers for fields and other groups and expose an STL compliant interface. 
The most important group is the root group (the top level group of the Nexus
tree). It can be obtained from an opened file via the {\tt root()} method
\begin{cppcode}
h5::nxfile file = h5::nxfile::open_file("test.nxs");
h5::nxgroup root = file.root();
\end{cppcode}

\subsection{Creating groups}

A new group can be created using the {\tt create\_group} method of a group
instance
\begin{cppcode}
h5::nxgroup entry = root.create_group("scan_1","NXentry");
\end{cppcode}
This method takes two arguments where the first one is mandatory and denotes the
name of the group while the second one is optional and determines the Nexus
class of the group. If the last argument is omitted a simple HDF5 group is
created (without an {\tt NX\_class}  attribute).

Like a file a group can be closed using its {\tt close()} method. However, as
with files this is not necessary as the group will be closed automatically when
it looses scope.

\subsection{Accessing children}

To some extent {\tt nxgroup} tries to mimic the behavior of an STL container. 
The {\tt size()} method returns the number of (direct) children of a group. 
Those children can be accessed via the {\tt at()} method or the
{\tt []} operator. Those functions/operators take either the name or the index 
of a child as its argument
\begin{cppcode}
h5::nxgroup root = file.root();
h5::nxgroup entry = root["entry"];
\end{cppcode}
Unlike for STL containers both access variants ({\tt at()} or {\tt []}) will 
throw an exception if a particular child could not be found or the index passed
to them exceeds the total number of children of the group.

\subsection{Group inquiry}

Like files, groups have a couple of inquiry functions. The most important ones
are shown here
\begin{center}
\begin{tabular}{l|l}
method & description \\
\hline\hline
{\tt is\_valid()} & returns true if the group is valid \\
\hline
{\tt name()} & returns the name of the group (not its full path though!) \\
\hline
{\tt size()} & returns the number of children for this particular group \\
\hline
{\tt parent()} & returns the parent group for this particular group \\
\hline
{\tt filename()} & returns the name of the file where this group is stored \\
\hline
\end{tabular}
\end{center}



%%%===========================================================================
\section{Working with fields}

Fields are the data holding units in Nexus.  In \libpniio\ fields are 
implemented by the {\tt nxfield} template. Before diving into the details there
are some important general remarks which must be made. One can imagine a field as a
multidimensional array of virtually arbitrary data. It is impossible to create 
a scalar field with \libpniio. The reason for this is simple: every field should
be extendible if needed. :w


\subsection{Creating fields}

Field creation is rather complex as there are many options which should be taken
into account. Lets start with a simple example
\begin{cppcode}
h5::nxgroup entry = root["entry"];
h5::nxfield field = entry.create_field<float32>("temperature");
\end{cppcode}
This creates a 1D field

\subsection{Reading and writing data}

Fields provide two basic methods for reading and writing data: {\tt read()} and 
{\tt write()}. 
Both member functions accept a single argument which can be an instance of the
following types
\begin{center}
    \begin{tabular}{l|p{0.6\linewidth}}
        {\bf type} & {\bf description} \\
        \hline
        \hline
        {\tt mdarray<...>} & an instance of the {\tt mdarray} template \\
        \hline
        {\tt array} & an instance of the array type erasure \\
        \hline
        {\tt T\& } & a single scalar value of the fields element type or a 
        convertible type \\
        \hline
    \end{tabular}
\end{center}
There is an additional version of the {\tt read()} and {\tt write()} methods
with the signatures {\tt read(size\_t n,T *value)}
and {\tt write(size\_t n,T *value)}. These functions exist as interface to
legacy C code where only pointers are available. As the user has to provide the
number of elements in the memory region where the pointers point to these
functions try to add some additional safety.

A typical example would look like this
\begin{cppcode}
auto data = dynamic_array<uint32>::create(shape_t{1024,1024});
h5::nxfield background = ....;

//writing
background.write(data);

//reading
background.read(data);
\end{cppcode}

\subsection{Partial reading and writing}

Nexus fields support partial IO with the {\tt ()} operator which applies
selections to the field instances. 
\begin{cppcode}
h5::nxfield spectra = ...;

auto s = spectra.shape<shape_t>();

auto spectrum = dynamic_array<uint32>::create(shape_t{s[1]});

for(size_t i=0;i<s[0];++i)
{
    spectra(i,slice(0,s[1])).read(spectrum);
    .... process data ...
}
\end{cppcode}
The selection mechanism works the same as for the {\tt mdarray} template. 

\subsection{Field inquiry}

%%%===========================================================================
\section{Iterating groups}\label{section:group_iteration}

\subsection{Simple iteration}

The {\tt nxgroup} type provides an STL compliant iterator interface to iterate
over the direct children of a group. In this very simple example we loop over 
all entries stored in a file
\begin{cppcode}
h5::nxgroup root = f.root();

for(auto entry: root)
    std::cout<<entry.name()<<std::endl;
\end{cppcode}
Another interesting example would be to count all instances of {\tt NXdetector} 
within an instrument group
\begin{cppcode}
#include <pni/core/types.hpp>
#include <pni/io/nx/nx.hpp>
#include <pni/io/nx/algorithms.hpp>

using namespace pni::core;
using namespace pni::io::nx;

//predicate function
bool is_detector(const h5::nxobject &o)
{
    if(is_group(o)) return is_class(o,"NXdetector");
    else return false;
}

int main(int argc,char **argv)
{
    h5::nxfile file = h5::nxfile::open_file("test.nxs");
    h5::nxgroup instrument = get_object(root,"/:NXentry/:NXinstrument");

    size_t ndetectors = std::count_if(instrument.begin(),instrument.end(),
                                      is_detector);
    std::cout<<"Found "<<ndetectors<<" detectors!"<<std::endl;
    return 0;
}
\end{cppcode}

\subsection{Recursive iteration}

\subsection{Deleting items}



%%%===========================================================================
\section{Working with attributes}


