%%%describing the basic usage

This chapter deals with the basic interface provided by the layer 1 types
implemented in \libpniio. All types concerning Nexus reside in one of the
namespaces embedded in {\tt pni::io::nx}. The namespaces below this one 
indicate either a particular storage backend (currently only HDF5 is
implemented).

To use the Nexus part of the library just add 
\begin{minted}{cpp}
#include <pni/io/nx/nx.hpp>
\end{minted}
to your source file. 

%%%===========================================================================
\section{Dealing with files}
The most fundamental thing one wants to do is to create, open, and close files. 
A typical usage pattern for a file object would look like this
\begin{minted}{cpp}
#include <pni/io/nx/nx.hpp>

using namespace pni::io::nx;

int main(int argc,char **argv)
{
    h5::nxfile file = h5::nxfile::create_file("test.nxs");
    //... code omitted ...
    file.close();

    return 0;
}
\end{minted}
To create the file we use the {\tt create\_file} static member method of the
{\tt nxfile} class. The available signatures for this function are
\begin{minted}{cpp}
create_file(const string &n,bool ow=false, ssize_t ssize = 0);
create_file(const string &n,bool ow);
create_file(const string &n,ssize_t ssize);
\end{minted}
\todo{Add the missing create\_file signatures to the library}
The arguments have the following meaning
\begin{center}
\begin{tabular}{l|l}
argument & description \\
\hline\hline
{\tt const string \&n} & name of the file \\
\hline
{\tt bool ow} & overwrite an existing file \\
\hline
{\tt ssize\_t sszie} & split size \\
\hline
\end{tabular}
\end{center}
It is important to note the last argument {\tt ssize}. If this argument is
passed and not equal $0$ the HDF5 backend will use the split-driver to write the
data. In this case the file will be split into individual files of size {\tt
ssize} (in MByte). This requires the file name to be a valid C format string
containing an integer index as shown in the next example
\begin{minted}{cpp}
h5::nxfile file = h5::nxfile::create_file("test.%04i.nxs",1024);
\end{minted}
Here the split driver will produced files of $1$GByte size with file names
\begin{minted}{bash}
test.0001.nxs
test.0002.nxs
test.0003.nxs
...
\end{minted}
If a file already exist the {\tt open\_file} static member function of the {\tt
nxfile} should be used. 
Its signature is rather simple 
\begin{minted}{cpp}
open_file(const string &n,bool ro=true)
\end{minted}
where the first argument is again the name of the file to open. The second
optional argument determines whether the file will be opened read-only (the
default) or in read-write mode. 

The file type provides some more methods which should be mentioned here briefly 
\begin{center}
\begin{tabular}{l|l}
method & description\\
\hline\hline
{\tt flush()} & call this method after writing data to ensure that it is written
to disk \\
\hline
{\tt is\_valid()} & return true if the file is valid \\
\hline
{\tt close()} & close a file \\
\hline
{\tt is\_readonly()} & returns true if the file was opened in read-only mode \\
\hline
{\tt root()} & return the root group of the file \\
\hline
\end{tabular}
\end{center}
There are two important remarks to make about files. The first concerns the {\tt
close()} method. It is usually not necessary to call this method explicitly as
the file will be closed automatically when it looses scope. 
The second bears the {\tt flush()} method. This is a rather useful method and
should be called anytime a particular amount of data which can be considered
consistent has been submitted to the file for writing. The {\tt flush()} method 
tells the operating system to take over and write the data.


%%%===========================================================================
\section{Working with groups}

Nexus groups are instances of the {\tt nxgroup} template. They can be considered
as containers for fields and other groups and expose an STL compliant interface. 
The most important group is the root group (the top level group of the Nexus
tree). It can be obtained from an opened file via the {\tt root()} method
\begin{minted}{cpp}
h5::nxfile file = h5::nxfile::open_file("test.nxs");
h5::nxgroup root = file.root();
\end{minted}

\subsection{Creating groups}

A new group can be created using the {\tt create\_group} method of a group
instance
\begin{minted}{cpp}
h5::nxgroup entry = root.create_group("scan_1","NXentry");
\end{minted}
This method takes two arguments where the first one is mandatory and denotes the
name of the group while the second one is optional and determines the Nexus
class of the group. If the last argument is omitted a simple HDF5 group is
created (without an {\tt NX\_class}  attribute).

Like a file a group can be closed using its {\tt close()} method. However, as
with files this is not necessary as the group will be closed automatically when
it looses scope.

\subsection{Accessing children}

To some extent {\tt nxgroup} tries to mimic the behavior of an STL container. 
The {\tt size()} method returns the number of (direct) children of a group. 
Those children can be accessed via the {\tt at()} method or the
{\tt []} operator. Those functions/operators take either the name or the index 
of a child as its argument
\begin{minted}{cpp}
h5::nxgroup root = file.root();
h5::nxgroup entry = root["entry"];
\end{minted}
Unlike for STL containers both access variants ({\tt at()} or {\tt []}) will 
throw an exception if a particular child could not be found or the index passed
to them exceeds the total number of children of the group.

\subsection{Group inquiry}

Like files, groups have a couple of inquiry functions. The most important ones
are shown here
\begin{center}
\begin{tabular}{l|l}
method & description \\
\hline\hline
{\tt is\_valid()} & returns true if the group is valid \\
\hline
{\tt name()} & returns the name of the group (not its full path though!) \\
\hline
{\tt size()} & returns the number of children for this particular group \\
\hline
{\tt parent()} & returns the parent group for this particular group \\
\hline
{\tt filename()} & returns the name of the file where this group is stored \\
\hline
\end{tabular}
\end{center}



%%%===========================================================================
\section{Working with fields}

Fields are the data holding units in Nexus.  In \libpniio\ fields are 
implemented by the {\tt nxfield} template. Before diving into the details there
are some important general remarks which must be made. One can imagine a field as a
multidimensional array of virtually arbitrary data. It is impossible to create 
a scalar field with \libpniio. The reason for this is simple: every field should
be extendible if needed. :w


\subsection{Creating fields}

Field creation is rather complex as there are many options which should be taken
into account. Lets start with a simple example
\begin{minted}{cpp}
h5::nxgroup entry = root["entry"];
h5::nxfield field = entry.create_field<float32>("temperature");
\end{minted}
This creates a 1D field

\subsection{Reading and writing data}

\subsection{Field inquiry}

%%%===========================================================================
\section{Iterating groups}\label{section:group_iteration}

\subsection{Simple iteration}

\subsection{Recursive iteration}

\subsection{Deleting items}



%%%===========================================================================
\section{Working with attributes}


