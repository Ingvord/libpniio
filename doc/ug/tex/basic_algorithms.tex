
When accessing the elements of a group or when retrieving the parent object of
an attribute the first question one may raises is: what kind of object is stored
in the \nxobject\ instance. 
There are basically three simple functions: \cpp{is\_attribute()},
\cpp{is\_field()}, and \cpp{is\_group()}. Each of these functions takes as their
single argument an instance of \nxobject. 
\begin{cppcode}
h5::nxgroup g = file.root();

for(size_t i=0;i<g.size();++i)
{
    auto object = g[i]; //this returns an instance of nxobject 

    if(is_field(object))
        std::cout<<"found a field"<<std::endl;
    else if(is_group(object))
        std::cout<<"found a group"<<std::endl;
    else
        std::cout<<"found unknown object type!"<<std::endl;
}
\end{cppcode}
The first line in this example, \cpp{h5::nxgroup g = file.root();} is a 
good example for implicit conversion. In fact \cpp{root()} returns an instance
of \nxobject\ rather than of \nxgroup. However, \nxgroup\ can be constructed 
from \nxobject\ as long as \nxobject\ stores an instance of \nxgroup.

There are also three conversion function templates available: \cpp{as\_field()}, 
\cpp{as\_group()}, and \cpp{as\_attribute()} each taking an instance of 
\nxobject\ and returning a field, group, or attribute instance. If the 
\nxobject\ argument does not store a value of appropriate type a
\cpp{type\_error} exception will be thrown. 
We could modify the \cpp{if} block in the above example with 
\begin{cppcode}
if(is_field(object))
    do_something_with_field(as_field(object));
else if(is_group(object))
    do_something_else_with_groups(as_group(object));
else
    std::cout<<"found unknown object type!"<<std::endl;
\end{cppcode}
None of these algorithms will work on either \nxfield, \nxgroup, or
\nxattribute. It would not make too much sense to ask an instance of \nxfield\
whether or not it is a field. We know this already. 

\subsection{Common algorithms for fields, groups, and attributes}

Fields, groups, and attributes share a set of common member functions which can
be accessed by a set of algorithms acting on an instance of \nxobject\ which 
stores either a field, a group, or an attribute. 

\subsubsection{\cppul{is\_valid()}}

One of the most important questions to ask from an object is whether or not it
is valid. The \cpp{is\_valid()} algorithms does exactly that. It behaves like 
the \cpp{is\_valid()} member function of \nxgroup, \nxfield, or \nxattribute. 
Indeed, this algorithms does not only work for \nxobject, \nxgroup, \nxfield,
and \nxattribute\ but also for \nxfile. Using it is fairly simple 
\begin{cppcode}
auto object = .....; 

if(!is_valid(object))
    std::cerr<<"Object not valid!"<<std::endl;
\end{cppcode}
The return value is of type \cpp{bool} and has the value \cpp{true} when the
object is valid, \cpp{false} otherwise.

\subsubsection{\cppul{close()}}

This template function works for \nxgroup, \nxfield, \nxattribute, and
\nxobject. It does what the name suggests: it calls the \cpp{close()} method of
the object passed as its only argument. 
\begin{cppcode}
auto object = ...; //can be either a field,group, attribute, or object

close(object);
\end{cppcode}
This function template has no return value.

\subsubsection{\cppul{get\_filename()}}

Calls the \cpp{get\_filename()} method on the object passed as an argument. The
function template works with \nxobject, \nxfield, \nxgroup, and \nxattribute. 
\begin{cppcode}
auto object = ...; //can be either a field,group, attribute, or object

std::cout<<"File is: "<<get_filename(object)<<std::endl;
\end{cppcode}
The return value is a string with the name of the file.

\subsubsection{\cppul{get\_root()}}

Returns the root group of the file an object belongs to. I accepts \nxobject,
\nxattribute, \nxfield, and \nxgroup\ instances as arguments. 
\begin{cppcode}
auto object = ...; //can be either a field,group, attribute, or object

h5::nxgroup root = get_root(object);
\end{cppcode}
The root group is returned as an instance of \nxobject. As shown in the short
code snippet above we do not have to care about this as \nxgroup\ can be
constructed from an \nxobject.

\subsubsection{\cppul{get\_name()}}

Returns the name of an object. The function templates takes an instance of 
\nxobject, \nxfield, \nxattribute, \nxgroup\ as its only argument
\begin{cppcode}
auto object = ...; //can be either a field,group, attribute, or object

std::cout<<"Name: "<<get_name(object)<<std::endl;
\end{cppcode}
The name is returned as a string. If the object is not valid an
\cpp{invalid\_object\_error} exception is thrown.

\subsubsection{\cppul{get\_parent()}}

Return the parent of an object. Takes an instance of \nxobject, \nxfield,
\nxattribute, and \nxgroup\ as its only argument
\begin{cppcode}
auto object = ...; //can be either a field,group, attribute, or object
auto p = get_parent(object);
\end{cppcode}
The parent object is returned as an instance of \nxobject. If the object is not
valid an \cpp{invalid\_object\_error} is thrown.

\subsubsection{\cppul{get\_path()}}

The \cpp{get\_path} function template takes either an \nxobject, \nxattribute,
\nxfield, and \nxgroup\ as its single argument.
\begin{cppcode}
auto object = ...; //can be either a field,group, attribute, or object
std::cout<<get_path(object)<<std::endl;
\end{cppcode}
The path is returned as a string. This is maybe not seem to be the best approach
but strings are most probably more often printed than used for iteration. 
However is a path object is required one can always do
\begin{cppcode}
nxpath p = nxpath::from_string(get_path(object));
\end{cppcode}

\subsubsection{\cppul{get\_size()}}

Returns the size of an object. This function template accepts an instance of 
\nxobject, \nxattribute, \nxfield, or \nxgroup\ as its single input argument.
\begin{cppcode}
auto object = ...; //can be either a field,group, attribute, or object
size_t n = get_size(object);
\end{cppcode}
The interpretation is slightly different whether or not the argument 
represents a group, a field, or an attribute. 
\begin{itemize}
\item for fields and attributes the return value is the total number of 
elements stored in the field or attribute 
\item for groups it is the total number of children.
\end{itemize}
