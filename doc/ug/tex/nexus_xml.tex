
\libpniio\ uses XML an XML dialect very similar to NXDL in order to serialize
\nexus-objects. The deviations from NXDL are due to the fact that \libpniio\ has
to build or dump concrete objects to XML rather than describing the fundamental
properties (as NXDL does). 
A good example here is the data type. NXDL uses \cpp{NX\_FLOAT} to denote that a
field or attribute has to be a floating point type. However, it does not
prescribe which one to use. For the purpose of NXDL this is not of importance -
the data type must be any of the available floating point types. 
\libpniio, on the oder side, needs to write objects to as well as to construct
objects from XML. Hence, a type like \cpp{NX\_FLOAT} would be too general. 

%%%===========================================================================
\section{Common deviations from NXDL}

This section deals with those deviations from NXDL which are common too all
objects in the \nexus-universe. 

\subsection{Data types} 

While NXDL uses general type descriptors like \cpp{NX\_FLOAT} or \cpp{NX\_CHAR} 
, which are more closely related to \libpnicore s type class concept, \libpniio\ 
uses the string representation of data types as described by the \libpnicore\
users guide. For a field one may uses 
\begin{minted}[fontsize=\small]{xml}
<field name="data" type="float32"/>
\end{minted}
where \cpp{float32} tells \libpniio\ exactly which floating point type to use.
Strings are represented by \cpp{string} instead of \cpp{NX\_CHAR}.

\subsection{Enumerations}

\libpniio\ does not support enumerations. An enumeration in NXDL lists the 
possible values a particular field or attribute can take. However, for
\libpniio\ the objects already has a particular state when it is written to XML
or has to be constructed in a particular state when read from XML. 
Enumerations thus would not make too much sense.

\subsection{Data in XML content} 

Unlike NXDL, \libpniio allows data to be stored in the XML output. This is 
particularly useful for scalar and rather small arrays of numeric data 
and strings. For numeric data all features are allowed. Data from multi
dimensional fields can easily be stored and read to and from XML. 
The data is simple dumped as a linear sequence of string representations of the 
numeric values separated by whitespace characters. 
As the dimensions of a multi dimensional field is stored in a special tag 
the field can easily constructed from the linear storage.

\subsubsection{The special case of strings} 

Strings are difficult. Thus only scalar string data can be currently stored. 
The reason for this is simple. While the ASCII representations of numeric data
can easily separated by whitespace characters, this is no longer the case for
strings. The whitespace maybe part of a single element. In other words, it is 
unclear what the delimiter characters are. 

\subsubsection{Binary data}

%%%===========================================================================
\section{XML attribute representation}

Attributes have to be represented by a dedicated tag if they are not mandatory
for a particular tag type. For instance the \cpp{group} and \cpp{type} attribute
are mandatory for virtually all objects and are thus always part of a tag. 
However, the \cpp{transformation\_type} attribute is optional for a \cpp{field}
tag and thus has to be encoded in a separate attribute tag. 

%%%---------------------------------------------------------------------------
\subsection{Scalar attributes}
\begin{xmlcode}
<attribute name="transformation_type" type="string"> rotation </attribute>
\end{xmlcode}
The \cpp{name} and \cpp{type} attributes have their obvious meaning and do not
need extra explanation. 
The data is kept in the \cpp{CDATA} section of the tag and needs to be parsed 
in case of reading.

%%%---------------------------------------------------------------------------
\subsection{Multidimensional attributes}

As of the NIAC meeting at the APS in December 2014 Nexus officially supports

\begin{xmlcode}
<attribute name="vector" type="float32">
    <dimensions rank="1">
        <dim value="3" index="1"/>
    </dimensions>
    0 1 0 
</attribute>
\end{xmlcode}

More interesting, how to manage multidimensional strings 
\begin{xmlcode}
<attribute name="log" type="string">
    <dimensions rank="1">
        <dim value="4" index="1"/>
    </dimensions>
    "line 1: blablabla" "line2: blablabla" 
    "line 3: more text" "line 4: the last line"
</attribute>
\end{xmlcode}
Strings must be stored quoted. This is important for the case of
multidimensional arrays as it would be hard otherwise to define a delimiter 
between the different strings. As a consequence it is not possible to store 
strings which contain a \".

%%%===========================================================================
\section{XML field representation}

%%%---------------------------------------------------------------------------
\subsection{Scalar fields}

\begin{xmlcode}
<field name="integral" type="uint16" units="cps"> 102 </field>
\end{xmlcode}
The attributes \cpp{name} and \cpp{type} have the same meaning as for 
attributes. More interesting is the \cpp{units} attribute as its meaning 
differs from NXDL. In NXDL the \cpp{units} attribute describes the 
dimension (length, angular, etc.) while in our serialization approach 
it represents a physical units. In this case this would be \emph{counts by 
second} (\cpp{cps}).

%%%---------------------------------------------------------------------------
\subsection{Multidimensional fields}

Multidimensional fields are described like multidimensional attributes 
\begin{xmlcode}
<field name="rotmat" type="float64" units="a.u.">
    <dimensions rank="2">
        <dim index="1" value="3"/>
        <dim index="2" value="3"/>
    </dimensions>
    1 2 3
    4 5 6
    7 8 9
</field>
\end{xmlcode}
Unfortunately this is not enough when we consider HDF5 as a storage backend. 
We definitely need more information.

%%%---------------------------------------------------------------------------
\subsection{Adding chunking}

The first thing required for HDF5 is that we have to store chunk information. 
\begin{xmlcode}
<field name="images" type="uint16" units="a.u.">
    <dimensions rank="3">
        <dim index="1" value="0"/>
        <dim index="2" value="1024"/>
        <dim index="3" value="2048"/>
    </dimensions>
    <chunk rank="3">
        <dim index="1" value="1"/>
        <dim index="2" value="1024"/>
        <dim index="3" value="2048"/>
    </chunk>
</field>
\end{xmlcode}

%%%---------------------------------------------------------------------------
\subsection{Adding compression}

\begin{xmlcode}
<field name="images" type="uint16" units="a.u.">
    <dimensions rank="3">
        <dim index="1" value="0"/>
        <dim index="2" value="1024"/>
        <dim index="3" value="2048"/>
    </dimensions>
    <chunk rank="3">
        <dim index="1" value="1"/>
        <dim index="2" value="1024"/>
        <dim index="3" value="2048"/>
    </chunk>
    <filters>
        <filter index="1" name="fletcher32"/>
        <filter index="2" name="deflate">
            <param name="rate"> 8 </param>
        </filter>
    </filters>
</field>
\end{xmlcode}

