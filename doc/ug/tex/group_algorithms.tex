
The set of algorithms described in this section make only sense in connection 
with a group object.

%%%===========================================================================
\subsubsection{\cppul{create\_field()}}

The \cpp{create\_field} function template works only with an instance of
\nxobject\ which stores an instance of \nxgroup. 
In the simplest case the \cpp{create\_field} 
\begin{cppcode}
auto detector = instrument["detector"];

auto field = create_field<float64>(detector,"../temperature");
\end{cppcode}
The template parameter of the \cpp{create\_field} function template, in this
example, determines the data type which should be used for the field. 
The first argument is the parent object for the field. In this example it is the 
group detector represented by an instance of \nxobject. The second argument is
the path to the new field. In this case this particular case the new field will
not be created no below the \emph{detector} but below the \emph{instrument}. In
fact, the parent object (the first argument) is just the starting point for the
path to the new field. The path must exist except for the last element (which is
the name of the newly created field). 
The path can either be passed to the function template as a string or as an
instance of \nxpath. 

Multidimensional fields can be created by appending the shape of the field 
to the list of arguments of the \cpp{create\_field} function template
\begin{cppcode}
auto detector = instrument["detector"];

auto field = create_field<float64>(detector,"background",shape_t{1024,1024});
\end{cppcode}
A filter can simply be added by appending it to the argument list
\begin{cppcode}
h5::nxdeflate_filter comp = ...;
auto detector = instrument["detector"];
shape_t shape{1024,1024};

auto field = create_field<float64>(detector,"background",shape,comp);
\end{cppcode}
A description of custom chunking can be found in
section~\ref{section:field_chunks}.
One of the disadvantages of these version of the \cpp{create\_field} function
template is the fact, that the data type can only be determined at compile time. 
To overcome this problem there is also a runtime version 
\begin{cppcode}
h5::nxdeflate_filter comp = ...;
auto detector = instrument["detector"];
shape_t shape{1024,1024};

auto field = create_field(detector,type_id::FLOAT64,"background",shape,comp);
\end{cppcode}
where the second argument is the type ID of the desired data type. All other
arguments are the same as for the previous versions of \cpp{create\_field}.

%%%===========================================================================
\subsubsection{\cppul{create\_group()}}

Creating groups using algorithms is much more powerful than the standard
\cpp{create\_group} method of \nxgroup. 
The \cpp{create\_group} algorithm requires two arguments where the first one is
the parent object for the new group and the second one the path to the new 
group. The \cpp{creat\_group} algorithm uses the \nexus-path syntax to determine
the type of the newly created group.
In it simplest form, in order to achieve the same result as with the 
\cpp{create\_group} member function, one could use
\begin{cppcode}
auto root = ...;
auto entry = create_group(root,"entry:NXentry");
\end{cppcode}
which would create a new group of name \cpp{entry} and of type \cpp{NXentry}.
A more elaborate example would be 
\begin{cppcode}
auto detector = ...
auto mono     = create_group(detector,"../monochromator:NXmonochromator");
\end{cppcode}
Instead of its string representation, an instance of \nxpath\ can be used 
to determined position, name, and class of the new group.



%%%===========================================================================
\subsubsection{\cppul{get\_child()}}

Retrieves the child of a group object. The child can be identified either by its
index or by its name (and class in case of a group). 
\begin{cppcode}
auto entry = ....;

for(size_t i=0;i<get_size(entry);++i) 
{
    auto child = get_child(entry,i);

    //do something with the child
}
\end{cppcode}
The parent can either be an instance of \nxgroup\ or \nxobject.  A
\cpp{type\_error} exception is thrown in the case that an \nxobject-parent does
not store an instance of \nxgroup.
More useful, however, is to search for a particular object by its type
\begin{cppcode}
auto instrument = ...;
auto detector   = get_child(instrument,"","NXdetector");
\end{cppcode}
or by its name
\begin{cppcode}
auto instrument = ...;
auto monitor    = get_child(instrument,"monitor");
\end{cppcode}
or even both
\begin{cppcode}
auto instrument = ....;
auto detector_1 = get_child(instrument,"det_1","NXdetector");
\end{cppcode}
In all, of the last three examples, if there are more than one instance in the 
parent which would satisfy the requirement, the first one will be returned. 

%%%===========================================================================
\subsubsection{\cppul{get\_children()}}
\todo[inline]{To be implemented}


%%%===========================================================================
\subsubsection{\cppul{get\_class()}}

The \cpp{get\_class} function template works for instances of \nxgroup\ and
\nxobject. It returns the value of the \cpp{NX\_class} attribute which 
determines the base class type of the group.
\begin{cppcode}
if(get_class(group) == "NXentry")
    //do something with the entry
else
    throw type_error(EXCEPTION_RECORD,"group is not an entry!");
\end{cppcode}
If the attribute is not set or does not exist the function returns an empty
string. 

%%%===========================================================================
\subsubsection{\cppul{get\_object()}}

Aside from the \cpp{get\_child} function template, this is most probably one of
the most important function templates presented in this section. 
The common methods to access children of a group usually only allow you to 
access the direct children of a group. The \cpp{get\_child} function template 
allows us to go beyond this limitation. 
We can use a path relative to a parent object
\begin{cppcode}
auto detector = ....;
auto monitor  = get_object(detector,"../:NXmonitor");
\end{cppcode}
Or even an absolute path
\begin{cppcode}
auto detector = ....;
auto monitor  = get_object(detector,"/:NXentry/:NXmonitor");
\end{cppcode}
Quite similar to \cpp{get\_child}, if several objects exist that would match
the path, the first one will be returned. The path to the object can be passed 
either as a string or as an instance of \nxpath.

%%%===========================================================================
\subsubsection{\cppul{get\_objects()}}
\todo[inline]{To be implemented!}

%%%===========================================================================
\subsubsection{\cppul{is\_class()}}

The \cpp{is\_class} function template checks if a group is an instance of a
particular base class. 
\begin{cppcode}
if(is_class(group,"NXentry"))
    //process NXentry
else
    throw type_error(EXCEPTION_RECORD,"group is not an instance of NXentry!");
\end{cppcode}
This function works for instances of \nxgroup\ as well as for \nxobject.  If
\nxobject\ does not hold an instance of \nxgroup\ a \cpp{type\_error} exception
will be thrown.

%%%===========================================================================
\subsubsection{\cppul{set\_class()}}

Set the base class type for a particular group. 
\begin{cppcode}
set_class(group,"NXentry");
\end{cppcode}
The first argument is the group for which to set the type. It must be either an
instance of \nxgroup\ or \nxobject. In the latter case a \cpp{type\_error}
exception is thrown if the \nxobject\ does not store a group instance.

If the group has already its \cpp{NX\_class} attribute set, the old value will be
overwritten.
