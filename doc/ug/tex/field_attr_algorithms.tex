
Fields and attributes are rather similar from a developers point of view. Most
algorithms working on attributes also work on field and vice versa. 

%%%===========================================================================
\subsubsection{\cppul{get\_unit()} -- fields only}

This function template accepts either an \nxobject-instance storing a field or
an instance of \nxfield. The \cpp{get\_unit} function template reads the 
\cpp{units} attribute from a field and returns its value (as a string). 
\begin{cppcode}
auto o = get_object(root,":NXentry/:NXdata/:NXdetector/data");
string detector_unit = get_unit(o);
\end{cppcode}
Alternatively one can use the function template with \nxfield
\begin{cppcode}
h5::nxfield field = get_object(....);
string detector_unit = get_unit(field);
\end{cppcode}
In principle it would be possible to retrieve an attribute also via the
attribute manager interface. Thus, this function template is merely a
convenience function.
In the case of an \nxobject\ argument a \cpp{type\_error} exception is thrown. 
For arguments of type \nxattribute\ and \nxgroup\ a compile time assertion 
fails and breaks the build.

%%%===========================================================================
\subsubsection{\cppul{set\_unit()} -- fields only}

\cpp{set\_unit()} is the counterpart of the \cpp{get\_unit} function. It is used
to set the value of the \cpp{units} attribute attached to a field. 
If the attribute does not exist it will be created, otherwise its content will
be overwritten. Like \cpp{get\_unit} this function template accepts either an
instance of \nxfield\ or an instance of \nxobject\ storing a field instance. 
\begin{cppcode}
//handle a field stored in nxobject
auto field = get_object(root,":NXentry/:NXdata/:NXdetector/data");
set_unit(field,"cps");
\end{cppcode}
or
\begin{cppcode}
h5::nxfield field = get_object(....);
set_unit(field,"cps");
\end{cppcode}
If an \nxobject\ argument does not store a field a \cpp{type\_error} exception
will be thrown. A failing compile time assertion will break the build in the 
case of an \nxgroup\ or \nxattribute\ argument.

%%%===========================================================================
\subsubsection{\cppul{create\_attribute} -- attributes only}

The \cpp{create\_attribute} function template creates, as its name suggests, 
an attribute attached to a field or group. The parent object for the attribute
must be passed as an instance of \nxobject. If the \nxobject-instance 
does not store a group or field a \cpp{type\_error} exception will be thrown. 
To create a scalar attribute 
\begin{cppcode}
auto field = get_object(root,":NXentry/:NXinstrument/:NXdetector/data");
auto attr = create_attribute<string>(field,"depends_on");
\end{cppcode}
As for the \cpp{create} member function of the attribute manager interface, 
every subsequent attempt to create an attribute on the same object with 
equal names will throw an exception. However, like for the attribute manager 
interface there is an overwrite flag
\begin{cppcode}
auto field = get_object(root,":NXentry/:NXinstrument/:NXdetector/data");
auto attr = create_attribute<string>(field,"depends_on");

// this would throw an exception
// attr = create_attribute<string>(field,"depends_on");

// however - this will work
auto attr = create_attribute<string>(field,"depends_on",true);
\end{cppcode}
For multidimensional attributes the shape has to be passed after the 
name of the attribute. 
\begin{cppcode}
auto detector = get_object(":NXentry/:NXinstrument/:NXdetector");
auto field = get_object(instrument,":NXtransformation/tth");
auto attr  = create_attribute<float64>(field,"offset",shape_t{3});
\end{cppcode}
Like for scalar attribute, in order to overwrite a multidimensional 
attribute, append the overwrite flag to the argument list. 
For both function templates runtime function exist where the 
datatype is passed as an instance of \cpp{type\_id\_t} 
allowing the pick the datatype at runtime
\begin{cppcode}
auto attr = create_attribute<string>(field,"depends_on",type_id_t::STRING);
\end{cppcode}

%%%===========================================================================
\subsubsection{\cppul{get\_attribute} -- attributes only}

The \cpp{get\_attribute} function template retrieves an attribute from either a
field or a group parent. The parent can be passed as an instance of \nxobject, 
\nxfield, or \nxgroup. The function currently only allows retrieval by name. 
\begin{cppcode}
auto g = get_object(root,":/NXentry/:NXinstrument");
std::cout<<get_name(get_attribute(g,"NX_class"))<<std::endl;
\end{cppcode}
If the requested attribute does not exist \cpp{key\_error} is thrown.

%%%===========================================================================
\subsubsection{\cppul{get\_rank()}}

This function template works for fields as well as for attributes and returns 
the number of dimensions of a field or attribute. In particular for
\emph{scalar} fields or attributes the results are slightly different. 
Unlike fields, attributes cannot alter their size. Consequently, the rank of an
attribute storing a single value is $0$. Fields can be resized and even if they
have a size of $1$ they can be extended along a single dimension. Thus, fields
have at least a rank of $1$. The function template accepts as its single 
argument, the object for which to determine the rank, as an instance of
\nxfield\ or \nxattribute. The application of the template is fairly 
easy
\begin{cppcode}
if(get_rank(attr) == 0)
    std::cout<<"scalar attribute"<<std::endl;
\end{cppcode}
or
\begin{cppcode}
if((get_rank(field) == 1) && (get_size(field)==1))
    std::cout<<"scalar field"<<std::endl;
\end{cppcode}

%%%===========================================================================
\subsubsection{\cppul{get\_shape()}}

Get shape returns a user defined container type with the number of elements
along each dimension from a field or attribute. Similar to \cpp{get\_rank}
there is a subtle difference in the output for scalar fields and scalar
attributes. For scalar attribute, having a rank of $1$, the return value is 
an empty container. For scalar fields the container has a single element whose
value is $1$. 
Using \cpp{get\_shape}, again, is rather simple
\begin{cppcode}
auto shape = get_shape<shape_t>(field);
\end{cppcode}
The only argument of \cpp{get\_shape} can either be an instance of \nxfield, 
 \nxattribute, or \nxobject.

%%%===========================================================================
\subsubsection{\cppul{get\_type()}}

Returns the type ID of the field or attribute passed to this function template. 
The argument can be either an instance of \nxobject, \nxfield, or \nxattribute.
In the former case a field or attribute must be stored in the \nxobject, 
otherwise \cpp{type\_error} will be thrown. 
\begin{cppcode}
auto object = get_object(parent,path);
type_id_t tid = get_type(object);

switch(tid)
{
    ....
};
\end{cppcode}


%%%===========================================================================
\subsubsection{\cppul{grow()}-- fields only}

The grow template function allows growing a field provides either as an instance
of \nxfield\ or \nxobject. The usage is quite similar to that of the \cpp{grow}
member function of \nxfield. The following snippet grows a field along its first
dimension by $100$ elements
\begin{cppcode}
auto field = get_object(root,":NXentry/:NXinstrument/:NXdetector/data");
grow(field,0,100);
\end{cppcode}

%%%===========================================================================
\subsubsection{\underline{\cpp{read()} \textrm{and} \cpp{write()}}}

The \cpp{read} and \cpp{write} functions work for attributes\footnote{As of
version 1.0.0, support for partial IO has been added to attributes. Hence, from
the point of reading and writing, attributes behave exactly the same as fields.}
as well as for fields. The read and write functions take either an instance of
\nxfield, \nxattribute, or \nxobject\ as an argument. To write or read an entire
field or attribute simply use
\begin{cppcode}
auto wbuffer = ....;
auto rbuffer = ....;

auto object = get_object(parent,....);
write(object,wbuffer);
read(object,rbuffer);
\end{cppcode}
One can also do partial IO with the \cpp{read} and \cpp{write} functions
(although the syntax maybe a bit strange)
\begin{cppcode}
auto wbuffer = ....;
auto rbuffer = ....;

auto object = get_object(parent,....);
write(object,wbuffer,0,slice(0,3),slice(0,5));
read(object,rbuffer,0,slice(0,3),slice(0,5));
\end{cppcode}
For partial IO just append the selection (as you would do it with the native ()
operator) to the argument list of \cpp{read} or \cpp{write}.

