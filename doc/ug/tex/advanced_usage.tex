%%%===========================================================================
\section{The mysterious \nxobject}\label{section:nxobject}
\input{tex/nxobject.tex}


%%%===========================================================================
\section{Using algorithms}\label{section:algorithms}

\nxobject\ does not expose any interface functions. Thus, all operations on 
instances of \nxobject\ are implemented as algorithms using the visitor pattern. 
Algorithms can be used by adding 
\begin{cppcode}
#include <pni/io/nx/algorithms.hpp>
\end{cppcode}
at the top of a source file. All the function templates provided 
reside with in the \cpp{pni::io::nx} namespace. 
Some of the algorithms also work with the standard types like \nxfield,
\nxgroup, and \nxattribute. Which one will be explained in the following
section.

\subsection{Basic inquiry and conversion}
\input{tex/basic_algorithms.tex}


\subsection{Group related algorithms}
\input{tex/group_algorithms.tex}

\subsection{Field and attribute related algorithms}
\input{tex/field_attr_algorithms.tex}

%%%===========================================================================
\section{Iterating groups}\label{section:group_iteration}

\subsection{Simple iteration}

The {\tt nxgroup} type provides an STL compliant iterator interface to iterate
over the direct children of a group. In this very simple example we loop over 
all entries stored in a file
\begin{cppcode}
h5::nxgroup root = f.root();

for(auto entry: root)
    std::cout<<entry.name()<<std::endl;
\end{cppcode}
Another interesting example would be to count all instances of {\tt NXdetector} 
within an instrument group
\begin{cppcode}
#include <pni/core/types.hpp>
#include <pni/io/nx/nx.hpp>
#include <pni/io/nx/algorithms.hpp>

using namespace pni::core;
using namespace pni::io::nx;

//predicate function
bool is_detector(const h5::nxobject &o)
{
    if(is_group(o)) return is_class(o,"NXdetector");
    else return false;
}

int main(int argc,char **argv)
{
    h5::nxfile file = h5::nxfile::open_file("test.nxs");
    h5::nxgroup instrument = get_object(root,"/:NXentry/:NXinstrument");

    size_t ndetectors = std::count_if(instrument.begin(),instrument.end(),
                                      is_detector);
    std::cout<<"Found "<<ndetectors<<" detectors!"<<std::endl;
    return 0;
}
\end{cppcode}

\subsection{Recursive iteration}
As we have seen in the previous section: iterating over the children of a group
is rather simple and works like with any other STL container. However, in many
cases iteration should run recursively over all objects of a group and its
subgroups. For this purpose \libpniio\ provides the \cpp{flat\_group} template. 
The \emph{flat} means that the entire structure below a group is
\emph{flattened} into a single linear container. The \cpp{flat\_group} provides 
a fully STL compliant container interface and thus, just like \nxgroup, can be
used along with all the algorithms provided by the STL. 

In the next example we want to print the path of all objects stored within an
entry to standard output
\begin{cppcode}
auto flat = make_flat(get_object(root,":NXentry"));

for(auto object: flat)
    std::cout<<get_path(object)<<std::endl;
\end{cppcode}
Note, that \cpp{flat\_group} is constructed using the \cpp{make\_flat} utility
function. The objects \cpp{flat\_group} returns are of type \nxobject. Thus, we
have to use the algorithms to work with them or convert them to their native
types.

\section{Deleting items}
\input{tex/removing_objects.tex}


%%%===========================================================================
\section{Custom field chunks}\label{section:field_chunks}
\input{tex/chunks.tex}

