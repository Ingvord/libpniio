%%%design overview over libpninx

The aim of \pninx\ is to provide an easy to use but yet powerful interface
to write Nexus files from C++. Although the Nexus group already provides 
an binding of their Nexus API (NAPI) for C++, this is not much more than a 
thin wrapper around the C library. Thus the native C++ API suffers from 
a whole bunch of features that a C++ programmer would expect from an API. 
\pninx\ is an approach to overcome the limitations of the native C++ API 
and provide you with all the object oriented features that C++ exposes.

In this chapter the general design of the library will be discussed. 
Though this section is usualy for developers only, users of the library 
are highly encouraged to read this chapter as it provides a lot of useful 
information about the philosophy behind certain objects. In particular 
section~\ref{section:nxfield_design} should be read by all users of \pninx. 

\section{Nexus and HDF5}

There is some confusion about how Nexus and HDF5 are related to each other. 
Mostly by people which know neither the one nor the other. 
So I will give an attempt to bring a bit light into this miracle. 
HDF5 is a binary file format which is primarily used to store numerical data. 
Each HDF5 file consist of primarily two kinds of objects: groups and datasets. 
The idea behind HDF5 is quite similar to that of a file system: the groups 
act like directories holding other groups and datasets while the datasets 
can be considered as files. In it simplest form a dataset can be treated as a 
multidimensional array of numbers of a particular data type. 
If you are familiar with the arrays provided by the {\tt numpy} package 
for Python you can directly map the anatomy of such an array to an HDF5 dataset. 
A {\tt numpy} array consist of a shape object which is simply a tuple holding 
the number of elements along each dimension and a data type (integer, float, or
whatever you have decided to store in the array). In HDF5 the shape is 
called data-space and the data type - well - is the data-type. 

Attributes can be attached to groups and datasets in an HDF5 file. One  can
imagine attributes as kind of tags that can be stuck on an object. 
Attributes by them self can be strings, arrays or whatever other data you might 
can think of. 


\section{Classes and implementation}\label{section:classes_implementation}

%%%----------------------------------------------------------------------------
\begin{figure}[tb]
\centering
\resizebox{\linewidth}{!}{\includegraphics{pics/class_inheritance.pdf}}
\caption{{\small\label{fig:class_inheritance}
Inheritance relations between the major objects provided by \pninx.
\nxobject\ is the root of the class tree but will hardly be used. 
The class important to a developer are the three classes derived from 
\nxobject: \nxfield, \nxgroup, and \nxfile.
}}
\end{figure}
%%%----------------------------------------------------------------------------
To keep the API simple, only a few classes are exposed. These classes and their 
relationship among each other are depicted in Fig.~\ref{fig:class_inheritance}. 
The top-level class is \nxobject. It provides the common functionality 
of every object within the API. \nxfield\ and \nxgroup\ divide the classes 
available in two groups: the former class is the base for all data holding
objects while the latter is the fundamental container class. 
\nxgroup\ corresponds with some extensions to a group in an HDF5 file or to 
a directory in a file-system (if you like this picture more). 

\begin{description}
\item[\nxgroup] the standard container to hold all kinds of objects
\item[\nxfield] the data holding objects
\item[\nxfile] object representing a data file.
\end{description}
\nxfile is a descendant of \nxgroup\ as can be seen in
Fig.~\ref{fig:class_inheritance}. Thus it posses all the functionality that 
\nxgroup\ has aside from those methods necessary for file handling. 
\pninx\ uses HDF5 to write data to disk. However, you do not have to know 
anything about HDF5. No low level HDF5 calls are necessary. Everything is 
masked by the three objects mentioned above. 
In order to do so a Bridge pattern~\cite{book:gof} was used for the
implementation. The idea was to separate the interface provided to the user from the 
concrete interface used to communicate with the HDF5 library. 
This allows us to change the HDF5 backend completely without changing 
user code using the library (maybe recompilation is needed - but this is not as
bad as changing code). This gives us much more freedom in maintaining \pninx.
The bridge pattern is not implemented as shown in \cite{book:gof} but rather 
by using a template approach as shown  in \cite{book:alexandrescu}.
Hence the code remains free of pointers which makes it much more readable. 
Furthermore it should be mentioned that the \pninx\ heavily relies on features 
provided by the C++11 standard. Thus, an actual compiler is required to 
build the library (for {\tt gcc} a version larger or equal $4.4$ is required).
 

\section{A closer view on \nxfield}\label{section:nxfield_design}
The classes derived form \nxfield\ are most probably the most important 
objects in the \pninx-universe as they are used to read from and write data to 
the file. From the point of C++, \nxfield\ can be considered a container like 
{\tt std::vector<>} or {\tt std::list<>}.
When an \nxfield\ object is newly instantiated it represents an empty container. 
Writing data to disk means nothing else than appending data to the container. 
To read data form disk means to fetch data from the container.
The size (number of elements) of the container is limited by the amount of 
free space on the storage device on which the file is written.
This means that you do not know the number of elements you want to write 
at the time of instantiating these objects. 
All classes derived form \nxfield\ mimic the behavior of a C++ container 
class in some or the other way.  So you will find methods like 
{\tt get()}, {\tt set()}, {\tt append()} and so on. However, some flavors
of these method may behave slightly unexpected. The reason for this is that 
unlike for a classical container there are tow points of how we can look 
on the data stored in such a container (this is in particular true for 
numeric data). 
There are basically three kinds of objects that can be stored in these container
\begin{enumerate}
  \item numerical data (\nxnumericfield)
  \item strings (\nxstringfield)
  \item and binary uninterpreted data (\nxbinaryfield)
\end{enumerate}
\nxfield\ can handle all different kinds of data which keeps the number of 
classes in the library small. However, there is a price one has to pay 
for this simplicity: \nxfield\ behaves slightly different depending 
on which kind of data is stored. 

\subsection{Numerical data}
%%%-----------------------------------------------------------------------------
\begin{figure}[tb]
\centering
\begin{minipage}[t]{0.39\linewidth}
\centering
\resizebox{\linewidth}{!}{\includegraphics{pics/container_scalar.pdf}}
\caption{{\small\label{fig:container_scalar} An \nxfield\ object holding 
scalar values can be either considered as a list of single scalar values 
or as a 1-dimensional array of numbers.}}
\end{minipage}
\hfill
\begin{minipage}[t]{0.58\linewidth}
\centering
\resizebox{\linewidth}{!}{\includegraphics{pics/container_array.pdf}}
\caption{{\small\label{fig:container_array}An \nxfield\ object with 2D-arrays 
of data can be either considered as a list of individual arrays or as a
single 3D array where the first dimension runs over the number of elements
and the other dimension correspond to those of the array data.}}
\end{minipage}
\end{figure} 
%%%-----------------------------------------------------------------------------
Numeric data is handled by the two templates \arrayt\ and \scalart\  
provided by \pniutils. For more information on this two templates see 
the users-guide of \pniutils.
Figures~\ref{fig:container_scalar} and \ref{fig:container_array} show how these 
two templates are stored in a field container. 
Basically we can treat data in two different ways: as a list of invididual
elements or, collectively, as a single array of data. 
Both approaches are are depicted in Figs.~\ref{fig:container_scalar} and 
\ref{fig:container_array}. A field storing scalars can be either considered 
as a list of individual numbers or as a 1D array of numbers. 
The same holds for arrays as shown in Fig.~\ref{fig:container_array}. Here 
we have either a list of individual 2D arrays or a single 3D array where the 
first index runs over the number of elements in the list while the remaining 
indices correspond to those of the 2D arrays.
Both points of view - the element wise or the collective view have their own 
applications and thus are taken into account in the API. 

\subsection{String data}
%%%-----------------------------------------------------------------------------
\begin{figure}[tb]
\centering
\begin{minipage}[c]{0.4\linewidth}
\centering
\resizebox{\linewidth}{!}{\includegraphics{pics/container_string.pdf}}
\end{minipage}
\hfill
\begin{minipage}[c]{0.58\linewidth}
\caption{{\small\label{fig:container_string} String fields can hold strings 
of different length. Each time a string is appended to the container 
a new entry is created. This can be used to store text files in a line-wise
manner. Each entry represents a line in the text-file.}}
\end{minipage}
\end{figure}
%%%-----------------------------------------------------------------------------
As usually strings are slightly different from everything else. 
This is also true for \pninx\ as shown in Fig.~\ref{fig:container_string}.
In the container view each element stores an individual string. The strings 
can have different length. 
As for numeric data one can either read individual strings or all strings 
in a single step. This would make it easy for instance to dump an entire 
ASCII file in such a string field. 

\subsection{Binary data}
%%%-----------------------------------------------------------------------------
\begin{figure}[tb]
\centering
\begin{minipage}[c]{0.4\linewidth}
\centering
\resizebox{\linewidth}{!}{\includegraphics{pics/container_binary.pdf}}
\end{minipage}
\hfill
\begin{minipage}[c]{0.58\linewidth}
\caption{{\small\label{fig:container_binary} Binary data is stored block wise.
Each container entry holds a block of constant size of data. Thus at 
field creation a block size must be passed to the creating factory method. 
If the block size is as large as the entire binary data only a single element 
must be stored representing the entire binary data.}}
\end{minipage}
\end{figure}
%%%-----------------------------------------------------------------------------
The last class of data supported by Nexus is binary data. 
Image files (JPEG, PNG,TIFF), PDF files or other binary data can be stored in
such a field. The binary stream is not interpreted. 
The interesting question is how to represent such a binary blob of data in 
a container view as it is provided by \nxfield?. 
Binary data is usually read in blocks of a certain size. So the elements
in the list are blocks. In the simplest case a block is only $1$ byte. 
In this case you can read data byte by byte and dump it to the field. 




 

