%%%documentation for NXGroup

\nxgroup\ is the fundamental object when it comes to structuring your file.
Everything what will be said about \nxgroup\ in this section holds for \nxfile\
too (it is a descendant of \nxgroup) too.
Groups are containers to hold \nxgroup\ or \nxfield\ objects.
Lets have a look on a simple example:

\inputminted[linenos=true]{c++}{../examples/c++/nxgroup_ex1.cpp}

A group is created using the {\tt create\_group} method provided by \nxgroup\ or
\nxfile\ objects (see lines 10-13). Several nested groups can be created using 
a single call as shown in line 13. The {\tt create\_group} method comes in 
two flavors: with one or with two arguments. In the former case the argument is
the path or name of the group and will simple create a group with that name
(path). The latter version of {\tt create\_group} takes the Nexus class 
of the group as a second argument. This method not only creates the group object
and attaches the {\tt NX\_class} attribute to it with a value determined by the 
second argument of the method.
Like all virtually all fundamental objects \nxgroup\ provides a {\tt close()}
method to close the object.
To open an existing group (this works for other objects too) you can either use
the {\tt open()} method of \nxgroup\ or \nxfile\ or the {\tt []} operator 
of these classes as shown in lines 16,17, and 20. In both cases the only
argument is the path to the group relative to the object that calls the method
or onto which the operator is applied. An absolute path can be used to access
objects which are located somewhere in the tree.

Although it is good practice to close all objects you have opened you do not

have to do so. As shown in this example too. When the objects loose scope they
become destroyed automatically. This is a good examples how using only first
class objects (no pointers to something) can improve code safety and simplicity.


\subsection{Working with attributes}

One of the most intriguing features of HDF5 and thus of Nexus is the concept of
attributes. Attributes are data-values that can be attached to every descendant
of \nxobject (which are \nxgroup, \nxfile, and \nxfield). An attribute can be considered basically pretty much like an 
\nxfield\ object although it has some limitations. It is, for instance, not
possible to grow a multidimensional attribute. Furthermore, attributes cannot be
compressed. 
The following examples gives a pretty good overview of what can be done with
attributes.
%%%--------------------------------------------------------------
\inputminted[linenos=true]{c++}{../examples/c++/nxgroup_ex2.cpp}
%%%--------------------------------------------------------------
The magic starts in line 15. An instance of \nxgroup\ is used to create a new
object of type \nxattribute. Such objects provide access to a particular
attribute. An instance of \nxattribute\ can be created using the {\tt attr<T>()}
template method provided by all classes derived from \nxobject.
The template parameters of this method determines the data-type to use for 
the attribute. In line 15 an attribute of type {\tt String} is created.
The only argument provided is a string with the name of the attribute. 
In this case a scalar attribute was created (one which holds only a single
value). In lines 16 and 19 the {\tt write} and {\tt read} methods of 
\nxattribute\ are used to write and read data to and from the attribute. 
Both methods are template so you should not case too much about the data type
you use for reading an writing such attribute as long as they are convertible. 
In lines 23 to 25 we do basically the same as before but for a {\tt Float32}
data-type. The interesting line here is 25. Here, a slightly different version
of the {\tt read} template method of \nxattribute\ is shown. Instead of passing
the target object to which the data should be read as an argument we tell the
method via a template parameter which object we would like to use to hold the
data. The method will then try to create such an object and returns it by value
to the calling program. As all objects in \pninx\ support move semantics you
should not care too much about performance issues in such a case. 

Until now we only created scalar attributes. In line 32 an array attribute is
created using the {\tt attr<T>()} template method. The template parameter again
determines the data-type to use for the attribute. However, to create an array
attribute we need to pass an additional argument to the method: the shape of the
array. In line 33 finally data is written to the attribute object.
Line 35 shows now the most elegant way how to obtain attribute data. Basically
we use the same {\tt read<T>()} template as in line 25 which does not only work
for primitive data-types but also for complex ones like arrays. 
The method does all the allocation and inquiry work us. We do not even specify
the type of the returned object (see left hand-side of the assignment operator).
Using {\tt auto} lets the decision up to the compiler. 

Now there are a few things left which one should to know about attributes. 
If you try to attach an attribute to an object which already posses an attribute
of same name an exception will be raised. However, this behavior can be
overridden by passing an additional argument to the attribute creation template
method telling the library to overwrite an already existing attribute. 
If one would like to use this feature line 23 of the above example must be
altered to 
\begin{minted}{c++}
    attr = g.attr<Float32>("temperature",true);
\end{minted}
where the last argument tells \pninx\ to overwrite an already existing attribute
of name {\tt temperature}. 
This works the same way for array attributes. Line 32 would change to
\begin{minted}{c++}
    attr = g.attr<UInt32>("vectors",wa.shape(),true);
\end{minted}
where again the last argument ensures that an already existing attribute would
be overwritten. 
It can be tedious to always use an instance of \nxattribute\ explicitly just to
write a simple attribute. So there is a simple shortcut for this. 
You can collate the code in lines 15 to 16 into
\begin{minted}{c++}
    g.attr<String>("description").write("a stupid data group");
\end{minted}

Finally the examples until now did not tell us anything how to obtain an
attribute from an already existing object. 
This can be done simply using the {\tt attr()} method provided by each object
(note that this method is not a template). It takes only one argument - the name
of the attribute. To open for instance the attribute from line 15 one would
simply type
\begin{minted}{c++}
    NXAttribute attr = g.attr("description"); 
\end{minted}
The method throws an exception if the attribute does not exist.



